# 实习part

供应链中台，整合各个业务的数据，包括电子面单、履约、停发区域。面向产品和运营侧。负责：后端和前端。

具体的，快递停发区域查询管理。

#### 业务需求上和代码设计：

		1. 由于一些历史遗留问题，现在有的数据源有地址元数据、原始版本、明细版本、合并版本等。（具体的，快递公司推送和运营线下收集的时间差和版本不一致，比如原始版本中京东和邮政的信息缺失，等）。——所以代码第一部分，定时任务， 从内存和数据库中读不同考核版本的数据，聚合指标，刷新es索引。
		1. 代码第二部分，从es索引以及数据库中读，汇聚和计算，返回接口数据。



#### 困难和解决：

1. 业务上：拿到一个需求，理顺它的业务逻辑比较难。
   1. 参考之前做过的前端需求，拉相应的后端代码。从grpc到service一层层向下剥。理清一条链路。
2. 技术和工具上：elasticsearch和grpc包括它的序列化格式protocolbuffer，之前不会。
   1. 看文档，先看官方文档，再看公司文档。
   2. 和之前不同的：
      1. 不用从头学到尾。只学两个：最核心的+项目要用的。
      2. 特别快。因为做需求替代了学习时候写demo。
3. 一个具体上的：微服务springboot在测试时的启动 -> 一路stackoverflow，在启动的application类中添加阿拉丁（快手对es框架封装和服务化的一套sdk）的扫描包路径 -> 学习spring的启动原理
4. code review，
   1. 写的代码比较靠近算法。（个人感觉:比较陈旧，尤其是大批量不同格式的数据，转换聚合的时候，嵌套地狱）
      1. 全是stream类，用的函数式编程思想 -> 在新项目中尽量锻炼了。
   2. 有一些边界条件的判断被忽略掉，以及埋点监控、配置告警。



### 自问自答

1. 具体使用的数据库是哪些？
   + 不会直接接触数据源。datasource数据库组件来访问数据源（由zookeeper动态配置）（mysql和clickhouse）。在依赖的服务中已经配置好了。使用MyBatis作为ORM框架。
   
     + `DataSource` 组件是快手为解决业务分库分表，查询删除，事务操作，监控打点等数据库操作做的简单封装组件
   
       <img src="https://raw.githubusercontent.com/tuysss/cloudimg/main/Typora-Notes-images/2023/01/10/0e3a2338526aa57d4d6690c39c89c741-20230110204455-3935e1.png" alt="image-20230110204453870" style="zoom:50%;" />
     
     + clickhouse是什么？ 列式存储（mysql行式）、OLAP、读场景
   + 缓存：对guava库的缓存工具包的封装。
   
2. 为什么使用rpc？和http有什么区别？grpc和它的关系是什么？
   + 在快手，服务与服务之间的集成通讯通常使用RPC方式，如果对接方是浏览器、客户端，或者公司外部服务，通常使用HTTP协议进行通讯。
   + *grpc*是基于*rpc*协议实现的一种框架。基于RPC模式，一个 RPC 框架基本需要解决 协议约定、网络传输、服务发现这三个问题
     + 协议约定。gRPC 的协议是 Protocol Buffers，是一种压缩率极高的序列化协议，Google 在 2008 年开源了 Protocol Buffers，支持多种编程语言，所以 gRPC 支持客户端与服务端可以用不同语言实现。
     + 传输协议。gRPC 的数据传输用的是 Netty Channel， Netty 是一个高效的基于异步 IO 的网络传输架构。Netty Channel 中，每个 gRPC 请求封装成 HTTP 2.0 的 Stream。
     + 服务发现。gRPC 本身没有提供服务发现的机制，需要通过其他组件。比如etcd插件。
       + KESS（Kuaishou Elastic Service Scheduler） 是快手统一的服务发现及治理平台，KESS平台和RPC框架、各类基础组件共同协作，为服务提供了服务注册发现、配置分发、流量调度等能力。
3. 定时刷新任务，用的redis分布式锁

4. 简单讲一下elastic search
   1. kuaishou-es 作为elasticsearch 操作的中间层，首先你得先有一个集群，在公共平台上申请。
   2. 











# 个人项目part

gitlet

+ 介绍：一个学习git的轻量的版本控制系统。
+ 主要难点：设计和架构。
  + 主要解决的核心问题是：.git仓库有哪些文件？各个区域如工作区暂存区版本库是如何划分的？核心实体branch-commit-blob之间的逻辑关系和物理存储是怎样的？
  + 解决方案的核心：用commit命令创建一个版本快照。

+ 和git区别：进行了简化。git对于快照的管理是commit指向tree指向blobs，gitlet将tree压成了链表，直接有commit指向blobs

+ 收获：

  1. 如上述，一个完整生态的架构，没有固定范式的。
  2. like《没有银弹》said，本质性和附属性，先充分理解自己的想法，把架构落到纸面上，再动手。不然一遍遍删了重写。
     1. 在实习项目中同感。

  2. 清晰注释真的很重要，大大加快了找bug的速度，也有利于后期维护
  3. 了解到自己的不足之处：debug能力不足，非常依赖autograder。



imooc

+ 现在看价值不是很大，主要的意义是用大作业push自己速学了java web以及相关框架，一条前后端的链路打通。以及和组员的合作吧。

























