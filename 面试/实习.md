供应链中台。后端和前端。

具体的，快递停发区域查询管理。

主要工作，1. 从内存和数据库中读不同考核版本的数据，刷新es索引。

​				   2. 从es索引以及数据库中读，汇聚和计算，返回接口数据。

困难和解决：

1. 微服务springboot在测试时的启动 -> 一路stackoverflow，在启动的application类中添加阿拉丁（快手对es框架封装和服务化的一套sdk）的扫描包路径 -> 学习spring的启动原理
2. 拿到一个需求，理顺它的业务逻辑比较难。
   1. 参考之前做过的前端需求，拉相应的后端代码。从grpc到service一层层向下剥。理清一条链路。
   2. 之前相对比较着急上手 -> 学习组内同学，按照架构图和时序图一步步缕清。
3. 技术和工具上：elasticsearch和grpc包括它的序列化格式protocolbuffer，之前不会。
   1. 看文档，先看官方文档，再看公司文档。
   2. 和之前不同的：
      1. 不用从头学到尾。只学两个：最核心的+项目要用的。
      2. 特别快。因为做需求替代了学习时候写demo。

4. code review，
   1. 写的代码比较靠近算法。（个人感觉:比较陈旧，尤其是大批量不同格式的数据，转换聚合的时候，嵌套地狱）
      1. 全是stream类，用的函数式编程思想 -> 在新项目中尽量锻炼了。
   2. 有很多边界条件的判断被忽略掉



### 自问自答

1. 具体使用的数据库是哪些？
   + datasource组件来访问数据源（由zookeeper动态配置）。在依赖的服务中已经配置好了。使用MyBatis作为ORM框架。
   + 内存：redis「相较于memcached，适用于较为复杂的数据结构，一定的持久化要求」

2. 为什么使用rpc？和http有什么区别？grpc和它的关系是什么？
   + 在快手，服务与服务之间的集成通讯通常使用RPC方式，如果对接方是浏览器、客户端，或者公司外部服务，通常使用HTTP协议进行通讯。
   + *grpc*是基于*rpc*协议实现的一种框架。基于RPC模式，一个 RPC 框架基本需要解决 协议约定、网络传输、服务发现这三个问题
     + 协议约定。gRPC 的协议是 Protocol Buffers，是一种压缩率极高的序列化协议，Google 在 2008 年开源了 Protocol Buffers，支持多种编程语言，所以 gRPC 支持客户端与服务端可以用不同语言实现。
     + 传输协议。gRPC 的数据传输用的是 Netty Channel， Netty 是一个高效的基于异步 IO 的网络传输架构。Netty Channel 中，每个 gRPC 请求封装成 HTTP 2.0 的 Stream。
     + 服务发现。gRPC 本身没有提供服务发现的机制，需要通过其他组件。
       + KESS（Kuaishou Elastic Service Scheduler） 是快手统一的服务发现及治理平台，KESS平台和RPC框架、各类基础组件共同协作，为服务提供了服务注册发现、配置分发、流量调度等能力。